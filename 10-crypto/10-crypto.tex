
%   COMP3310 crypto tutorial
%   Written by Hugh Fisher, ANU, 2024
%   Creative Commons CC-BY-4.0 license

%   LaTeX markup for XeTeX with a standard texlive distribution
%   Command to build:
%       xelatex 10-crypto.tex

\input{../common/formatting}

\begin{document}

\TITLE{Signatures and Encryption}


\MINOR{Outline}

In this tutorial you will

\DOT Check the cryptographic signatures of files

\DOT Find how many certificates your computer has

\DOT Study a simple program using an encrypted socket


\SECTION{Cryptographic Signatures}

\STEP The first program to look at is \NAME{hashSig.py} or \NAME{HashSig.java}
which calculates a \emph{signature} or \emph{digest} for a single file. We
will start by running it on the source of the program itself. Run the Python
version \texttt{python hashSig.py hashSig.py} or compile the Java version and
then run \texttt{java HashSig HashSig.java}. The program will print out a
string of hex digits representing a 128 bit number.

Open the source code in your favourite text editor. Change one digit in the
\SQ{2024} date given in the header comment (and save). Run the program again:
how many digits change in the printed signature?

Within the program code find the \texttt{hash} code. This is typical of how a
checksum or signature is calculated: first the calculation algorithm is chosen and
initialised, then the \SQ{data} is fed through the calculation byte by byte.
The final result is always a fixed sized number, no matter how few or how
many bytes of data are given.

\STEP If the command line argument is \texttt{-list} rather than a file name,
the program prints out all the different cryptographic signature algorithms
available on your computer. Do this.

Run the program on the source code again, but this time with a second command
line argument for example \texttt{SHA1}. How many bits are there in this signature?

\STEP Signatures can be used to verify that a copy of a file (usually a download)
has not been tampered with. For this tutorial we will look at the site
\CODELINE{https://openssl.org/source/}

The file we are interested in is \texttt{openssl-3.30.tar.gz} but \textbf{don't}
download it straight away. Ask your tutor for a copy of the file, or for where
a copy of the file is stored on the CECC lab computers.

Next to the file name are signatures, at time of writing SHA256, PGP, and SHA1.
You \textbf{should} download the two SHA signatures, each of which is a very
short text file.

Once you have your own copy of \texttt{openssl-3.30.tar.gz}, run the hash
program on it with one of the SHA signature algorithms. Compare the printed
result to the downloaded signature file. Do they match?

If someone can break into the OpenSSL web site and upload their own copy of
the program, can you trust the signature?


\SECTION{Certificates}

\STEP Web server security (and other applications) depends on certificates
and Certfication Authorities. Program \NAME{showCerts.py},
no command line arguments, prints out the certificates on the host.
Do this, and be prepared to scroll back up to see them all: a typical computer
has fifty to over a hundred.

\STEP The command line option \texttt{-v} will print out more details about
each certificate instead of just a name. Do this.

\textbf{Don't Panic}. We are not going to study all these fields in detail,
and you don't have to remember what each one is for. The lesson to learn
is that setting up a world wide system for secure network communication is
complicated.

The code for this program is not very useful, it exists only so the same
tutorial instructions work on all the computers students are likely to have.
(And there is no Java version because the code is awful.)

If you decide you do want to learn more about how all this works, CECC
has a course for you: TODO SECURITY COURSE NAME.


\SECTION{Secure sockets}

Here we will be using WireShark to watch an encrypted socket connection
to the ANU web site. Start WireShark, and enter the filter
\CODELINE{port 443 and host www.anu.edu.au}
before capturing the external Internet interface of your computer. (Not the
loopback.) Port 443 is for https, HTTP secure.

\STEP The program for this section is \NAME{sslClient.py} or \NAME{SSLClient.java}.

Have a quick look at the source code. This program is similar to the
\texttt{TCP Client}
tutorial exercise: it reads input lines, sends them to a server, and reads and
prints any response. The most important new code is \texttt{openSSL}, which
creates an encrypted socket connection to the server.

Run the program without any arguments, which will connect to the ANU web server.
In WireShark you should see a standard TCP socket
\texttt{SYN SYN ACK} triple handshake.
Next the client and server negotiate the encrypted connection, with
\texttt{Client Hello} and \texttt{Server Hello} packets and a few more.

After creating the secure socket the program prints out some connection details.
Who issued the certificate for the ANU web server? When will it expire?

The program now waits for your input to send. Try
\begin{CODE}\begin{verbatim}
    GET / HTTP/1.1
    Host: www.anu.edu.au
    
\end{verbatim}\end{CODE}

(Don't forget the blank line to finish.)
Assuming your request is correct, the server will reply with the HTML for a web
page. Click on a few packets in Wireshark: your request and the reply, although
originally text, are encrypted as binary data and cannot be read.

Now go back to the source code.

The new \texttt{openSSL} creates a secure socket that is \DQ{wrapped} around the
underlying TCP connection. And there is the \emph{handshake} where the client and
server agree on what cryptographic algorithm and keys to use.

\emph{The rest of the program does not need to change.} A secure socket implements
the same methods as before, but now data is encrypted before being sent and
decrypted when received.

(Actually there are some differences: for instance a half shutdown on a secure
socket will break things. But sending and receiving, the common case, just works.)

The program can be given a hostname on the command line for connecting to
different web servers. Try a few other sites and see if they use different
encryption algorithms.

Secure network programming is both complicated and simple. As the certificates
program shows, there are a lot of parts involved that all need to work together.
As the secure socket program shows, it is not very difficult to create a more
secure network connection when the underlying system has these parts.


\COPYRIGHT

\end{document}
